int firstOccurence(vector<int> nums,int n , int x){
   int low =0;
   int high = n-1;
   int first=-1;
   while(low<=high){
    int mid = (low+high)/2;
    if(nums[mid]==x){
      first = mid;
      high = mid-1;
    }else if(nums[mid]>x){
        high = mid-1;
    }else{
        low = mid+1;
    }
   }
   return first;
}

int lastOccurence(vector<int> nums,int n , int x){
   int low =0;
   int high = n-1;
   int last=-1;
   while(low<=high){
    int mid = (low+high)/2;
    if(nums[mid]==x){
      last = mid;
      low = mid+1;
    }else if(nums[mid]>x){
        high = mid-1;
        
    }else{
        low = mid+1;
    }
   }
   return last;
}
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int x) {
    //   Brute : TC =O(n), SC=O(1);
    //   int first=-1;
    //   int last =-1;
    //   int n = nums.size();
    //   for(int i=0;i<n;i++){
    //     if(nums[i]==x){
    //         if(first==-1){
    //             first =i;
    //         }
    //         last=i;
    //     }
    //   }
    //    return {first,last}; 

    // Optimal : using Lower bound and Upper bound
    // int n = nums.size();
    // auto it = lower_bound(nums.begin(),nums.end(),x);
    // int first = it - nums.begin();
    // if(first == n || nums[first] != x ){
    //     return {-1,-1};
    // }
    // auto it1 = upper_bound(nums.begin(),nums.end(),x);
    // int second = it1 - nums.begin();
    // return {first, second-1};
    // }

    // Optimal : using binary search topic
   int n = nums.size();
   int first = firstOccurence(nums,n,x);
   int second = lastOccurence(nums,n,x);
   return {first,second};
    }
};
