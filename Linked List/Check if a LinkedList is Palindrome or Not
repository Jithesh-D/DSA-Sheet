/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
 ListNode* reverseList(ListNode* head) {
        ListNode* prev = NULL;
        ListNode* curr = head;
         ListNode* next= NULL;
         while(curr != NULL){
            next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
         }
        return prev;
    }
 bool isPalindrome(ListNode* head){
   ListNode* fast = head;
   ListNode* slow = head;

  while(fast->next != NULL && fast->next->next != NULL){
    slow = slow->next;
    fast = fast->next->next;
  }
   ListNode* newhead; 
   newhead = reverseList(slow->next);
   ListNode* temp =head;

   while(newhead!= NULL){
    if(temp->val != newhead->val){
        reverseList(slow->next);
        return false;
    }
        temp = temp->next;
    newhead = newhead->next;
   }
    reverseList(slow->next);
    return true;
 }

};

    // bool isPalindrome(ListNode* head) {
    //     ListNode* temp = head;
    //     stack<int>st;
    //     while(temp!=NULL){
    //         st.push(temp->val);
    //         temp=temp->next;
    //     }
    //     temp=head;
    //     while(temp!=NULL){
    //         if(temp->val != st.top()){
    //             return false;
    //         }
    //         st.pop();
    //         temp=temp->next;
    //     }
    //     return true;
    // }
// };
